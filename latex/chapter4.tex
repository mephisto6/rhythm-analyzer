%----------------------------------------------------------------------------
\chapter{A megvalósítás}
%----------------------------------------------------------------------------

Az elõzõ fejezetekben definiáltam egy problémát számos megoldási lehetõséggel. A feladatom az volt, hogy hozzak létre egy szoftvert, amely erre a problémára választ ad. Ehhez implementálni kellett a kották beolvasását, a ritmus kinyerését, a távolságok meghatározását, a klaszterezés futtatását és az eredmények megjelenítését. 

A szoftver elkészítéséhez a Java nyelvet választottam annak platformfüggetlensége, széleskörû elterjedtsége, támogatottsága és rendelkezésre álló funkcionalitásának sokszínûsége miatt.

A kód, a dokumentáció, illetve a grafikus elemek szövegei is mind angolul készültek.

%----------------------------------------------------------------------------
\section{Forrásfájlok feldolgozása}
%----------------------------------------------------------------------------

A vizsgálandó dalok nem hangfájlként állnak rendelkezésre, hanem speciálisan kódolt kották formájában. Ezek sorai megfelelnek egy hagyományos kotta sorainak, a sorok elemei pedig tartalmazzák az egymást követõ hangok magasságát és idõtartamát.

\begin{lstlisting}[frame=single,captionpos=b,caption={Egy kódolt kotta},label={list:kotta}]
T1/2 K2b [8G2 8G2 8G2 8G2] |K2b [8H2 8H2 8A2 8G2] |K2b 8A2 4F2. |
     K2b [8G2 8G2 8A2 8G2] |K2b [8F2 8E2 8D2 8C2] |K2b 8D2 4H1. |
     K2b 4D2 [8D2 8C2] |K2b [8H1 8H1 8C2 8H1] |K2b 8A1 4G1. |
     K2b [8H1 8H1 8A1 8G1] |K2b [#8F1 8G1 8A1 8H1] |K2b 4G1 R4 |

\end{lstlisting}

A \ref{list:kotta}-es fájlban egy ilyen speciálisan kódolt kottát láthatunk. A fájl elsõ eleme az ütemek hosszát határozza meg. Az ütemek között (az igazi kottához hasonlóan) függõleges vonal ($|$) található, a kottában is szereplõ gerendákat pedig nyitó és záró szögletes zárójel ($[$ és $]$) jelöli, de ezek számunkra nem hordoznak lényeges információt. 

Az ütemek elsõ eleme opcionális hangmagasság-módosító, ezért a ritmus vizsgálatakor figyelmen kívül hagyhatjuk. Utána jönnek a hangok, melynek elsõ része határozza meg a hang hosszát, második a magasságát. A \ref{list:kotta}-es fájl elsõ hangot reprezentáló eleme a $8G2$, mely egy $1/8$ hosszúságú $G$ hangot jelöl a második oktáv magasságában.

A félhangot módosító, tetszõleges számú $b$, vagy \# közvetlenül a hang elõtt is állhat, ahogy az látható a negyedik sor második ütemében szereplõ $\#8F1$ hangnál. Az $R$-rel kezdõdõ elemek szüneteket jelölnek, melyek hosszát a mellettük álló szám jelöli (pl. az utolsó sor végén látható $R4$ egy $1/4$ hosszú szünetet takar).

Pontozott hangok itt is elõfordulhatnak, a pont helye a hangot jelölõ kód utolsó pozíciója, szerepe pedig a hang hosszának másfélszerezése (ilyen pl. az elsõ sor utolsó eleme: $4F2.$, melynek hossza így $1/4+1/8=3/8$).

%----------------------------------------------------------------------------
\subsection{A dalokat reprezentáló objektumok}
%----------------------------------------------------------------------------

Az egyes fájlokban tárolt adatokkal megadott dalokat egy objektum-hierarchiába képeztem le (\ref{fig:uml01} ábra). 

\begin{figure}[!h]
\centering
\includegraphics[width=55mm, keepaspectratio]{figures/uml1.png}
\caption{A dalokat reprezentáló objektumok hierarchiája} 
\label{fig:uml01}
\end{figure}


A teljes dalhoz tartozó osztály a  \texttt{Tune} nevû osztály, mely tartalmazza a hozzá tartozó fájl referenciáját is. A \texttt{Tune} osztály \texttt{TuneLine} objektumokból épül fel, melyek mindegyike egy-egy sort reprezentál az adott fájlban. A sorok ütemekbõl épülnek fel, ugyanígy egy \texttt{TuneLine} objektum az ütemet reprezentáló \texttt{Bar} típusú objektumok kompozíciója. 

Minden szinten találhatóak olyan mezõk, melyek az adott szinten értelmezhetõ ritmusvektor kiszámításához szükségesek. Az alkalmazásban a \texttt{TuneLine} osztály lett a felelõs a vektorok \texttt{Bar} objektumból származó részleteinek összeállításáért. 

Mivel nagyon gyakori, hogy a dalok ritmusa nem, vagy alig változik a sorok között, az a döntés született, hogy az elsõ sort választjuk ki az összehasonlítások alapjául, majd ha szükséges, további elemzéseket futtatunk a többi sorra.

%----------------------------------------------------------------------------
\section{A forrásfájlok katalógusa}
%----------------------------------------------------------------------------

Az adatbázis felépítéséhez szükséges fájlok egy hierarchikus könyvtárstruktúrában találhatóak. A témával foglalkozó korábbi eljárások \cite{Juhasz} egy katalógusfájl segítségével azonosítják a dalokat, mely egy egyszerû kulcs-érték párosnak fogható fel. A kulcs a fájlban elfoglalt sor sorszáma ($1$-tõl indulva), az érték pedig a sor tartalma, mely egy relatív útvonalat tartalmaz a fájlhoz (\ref{list:katal}-es fájl).

\begin{lstlisting}[frame=single,captionpos=b,caption={A katalógusfájl részlete},label={list:katal}]
data/kotta/par1.knf
data/kotta/ahol2.knf
data/kotta/felj3.knf
data/kotta/megr4.knf
data/kotta/enm5a.knf
data/kotta/enm5b.knf
data/kotta/enm5c.knf
\end{lstlisting}

Az itt látható $data/kotta/par1.knf$ bejegyzés sorszáma például $1$, és így tovább a többi értelemszerûen.

%----------------------------------------------------------------------------
\section{Ritmusábrázolás}
%----------------------------------------------------------------------------

A fájlokból elsõ lépésben a korábban ismertetett TUBS ábrázolású vektorokat nyerjük ki. Ehhez meghatározunk egy $n$ egész számot, mely lehetõleg $2$ hatvány, majd azt mondjuk, hogy az egységnyi ütemet ennyi üres dobozra osztjuk. Ezután beletesszük az elemeknek megfelelõ $1$-eseket a pozíciójukba. $16$-os felbontást feltételezve a \ref{list:kotta}-es kotta elsõ sora így ábrázolható:
\[ \left( \begin{array}{cccccccccccccccccccccccccc}
1& 0& 1& 0& 1& 0& 1& 0& |& 1& 0& 1& 0& 1& 0& 1& 0& |& 1& 0& 1& 0& 0& 0& 0& 0
\end{array} \right)
\]
hiszen a nyolcadhangok ekkor kettõ helyet foglalnak el a listában, az utolsó pontozott negyed pedig hatot.

Az ugyanehhez a sorhoz tartozó intervallumok hosszait reprezentáló vektor a pedig a következõképp írható fel:
\[ \left( \begin{array}{cccccccccccc}
2& 2& 2& 2& |& 2& 2& 2& 2& |& 2& 6
\end{array} \right)
\]
amely az elõzõ vektorból könnyen számolható az $1$-esek közötti $0$-k számának megszámolásával ($+1$).

A szomszédos elemekhez tartozó arányok az intervallumok hosszait reprezentáló vektorból számíthatók a szomszédos elemek hányadosának sorba vételével:
\[ \left( \begin{array}{cccccccccccc}
1.00& 1.00& 1.00& 1.00& |& 1.00& 1.00& 1.00& 1.00& |& 3.00& 0.33
\end{array} \right)
\]

A hangsúlyos elemek pozícióit tartalmazó vektor:
\[ \left( \begin{array}{cccccccccccc}
1& 3& 5& 7& |& 9& 11& 13& 15& |& 17& 19
\end{array} \right)
\]

\begin{figure}[!h]
\centering
	\begin{tikzpicture}
	\begin{axis}[ymin=0,ymax=6.2,enlargelimits=false]
	\addplot
	[const plot,blue, thick]
	coordinates
	{(0,    2) (12,    6) (16,    6)};
	\fill [blue,fill=blue!20] (axis cs:0,0) rectangle (axis cs:12,2);
	\fill [blue,fill=blue!20] (axis cs:12,0) rectangle (axis cs:16,6);
	\end{axis}
	\end{tikzpicture}
\caption{A példa fájl kronotonikus lánca}
\label{fig:fig16}
\end{figure}

A kronotonikus lánc pedig:
\[ \left( \begin{array}{cccccccccccccccccccccccccc}
2& 2& 2& 2& 2& 2& 2& 2& |& 2& 2& 2& 2& 2& 2& 2& 2& |& 2& 2& 6& 6& 6& 6& 6& 6
\end{array} \right)
\]
melyet a \ref{fig:fig16} ábrán láthatunk grafikusan ábrázolva.

%----------------------------------------------------------------------------
\section{A komparátorok}
%----------------------------------------------------------------------------

A ritmusok reprezentációinak elkészítése után a következõ lépés az összehasonlításért felelõs osztályok megírása volt. Az objektum-orientáltság szellemében ezek egy közös, \texttt{Comparer} nevû absztrakt osztály gyermekei (\ref{fig:uml02} ábra), mely az összehasonlító metóduson kívül minden más segédeljárást tartalmaz (ilyen pl. a számított távolságmátrix formázott kiírása, fájlba mentése, stb.).

\begin{figure}[!h]
\centering
\includegraphics[width=150mm, keepaspectratio]{figures/uml2.png}
\caption{A komparátor objektumok hierarchiája} 
\label{fig:uml02}
\end{figure} 

A következõ osztályok implementációi felelnek meg egy-egy korábban definiált ritmikus összehasonlító módszernek:
\begin{itemize}
	\item \texttt{HammingDistanceComparer}
	\item \texttt{ManhattanDistanceComparer}
	\item \texttt{EuclideanDistanceComparer}
	\item \texttt{IntervalDiffDistanceComparer}
	\item \texttt{SwapDistanceComparer}
	\item \texttt{ChronotonicDistanceComparer}
	\item \texttt{ContinousChronotonicDistanceComparer}
\end{itemize}

%----------------------------------------------------------------------------
\section{A klaszterezések}
%----------------------------------------------------------------------------

A klaszterezõ algoritmusok mindegyikének szintén egy-egy osztály felel meg. Ezek az osztályok a \texttt{Classifier} közös absztrakt õsosztályból származnak, név szerint:
\begin{itemize}
	\item \texttt{SingleLinkageClassifier}
	\item \texttt{CompleteLinkageClassifier}
	\item \texttt{AverageLinkageClassifier}
	\item \texttt{RandomKMeansClassifier}
	\item \texttt{FirstRandomKMeansClassifier}
	\item \texttt{FarthestFirstKMeansClassifier}
	\item \texttt{DBSCANClassifier}
\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[width=150mm, keepaspectratio]{figures/uml3.png}
\caption{A klaszterezõ objektumok hierarchiája} 
\label{fig:uml03}
\end{figure} 

A rendelkezésre álló hierarchikus klaszterezés alapvetõ implementációi (single, complete és average linkage) egy köztes õsbõl (\texttt{LinkageClassifier}) származnak, és csak abban az egy metódusban térnek el, hogy hogyan határozzák meg a következõ összevonandó klasztereket (\ref{fig:uml03} ábra). 

Ugyanez mondható el a különbözõ particionáló módszerekrõl is, ahol a kezdeti klaszterezés megválasztásától eltekintve minden funkcionalitást a közös õs, a \texttt{KMeansClassifier} osztály tartalmaz.

%----------------------------------------------------------------------------
\subsection{A klaszterezések jóságának mérése}
%----------------------------------------------------------------------------

Mind a $k$-means, mind a DBSCAN implementációi igényelnek egy célfüggvényt, melyet minimalizálni szeretnének. Számos, \ref{sect:klasztjell} szakaszban definiált metrikát megvalósítottam, melyek a \texttt{MetricsUtils} osztály statikus metódusai közé kerültek. Mindegyikük egy paraméterként kapott klaszterlista alapján egy dupla pontosságú lebegõpontos nemnegatív értéket ad vissza. 


A választott nyelv által megkövetelt objektumorientáltság alapelve, hogy az adatok és a hozzájuk tartozó manipuláló eljárások egy objektumba legyenek foglalva. Ezt szem elõtt tartva bizonyos, adott klaszterre jellemzõ mértékek (pl. klaszterátmérõ, klaszteren belüli távolságok összege) kiszámításáért a \texttt{Cluster} nevû segédosztály lett a felelõs, mely egyébként a klaszterpéldányokat reprezentálja (mezõi: középpont, elemek, stb\dots).

%----------------------------------------------------------------------------
\section{Futtató felület}
%----------------------------------------------------------------------------

Az alkalmazás számos futtatási módjának és azok paramétereinek könnyû kezelhetõsége miatt grafikus felületet kapott, melyet az Eclipse SWT (Standard Widget Toolkit) grafikus könyvtárát használva valósítottam meg. 

Az SWT az operációs rendszer grafikus megjelenítést végzõ szubrutinjai fölötti natív objektumok Java csomagolóinak halmazának tekinthetõ \cite{SWT}. Minden platformon elérhetõ és mindegyik különbözõképp néz ki, illeszkedve az adott környezetre jellemzõ kinézetre. A \ref{fig:win01}-ös ábrán látható a fejlesztéshez használt Windows 7-es operációs rendszeren kapott felület.

\begin{figure}[!h]
\centering
\includegraphics[width=150mm, keepaspectratio]{figures/window_clint.png}
\caption{A grafikus futtató felület} 
\label{fig:win01}
\end{figure}

Az ablak tetején található eszközök segítségével választható ki a forrásadatbázis helye, melyet egy könyvtárválasztó párbeszédablak (\ref{fig:win02} ábra) tesz könnyûvé. Az adatbázis a megadott könyvtárban és annak összes alkönyvtárában található kódolt kották alapján épül fel, így a könyvtárstruktúrában hierarchikusan elrendezett fájlok külön csoportonként is vizsgálhatóak.

Lehetõség van arra, hogy a fájlokat a katalógusfájlban szereplõ azonosítójuk segítségével egyesével adjuk meg, így a fájlhierarchiát nem követõ csoportokat is elemezhetünk. A korábbi kutatásokból származó dallam-alapú klaszterbe tartozó dalok azonosítóinak megadását legördülõ menü teszi még egyszerûbbé.

\begin{figure}[!h]
\centering
\includegraphics[width=70mm, keepaspectratio]{figures/window2.png}
\caption{Mappaválasztó párbeszédablak} 
\label{fig:win02}
\end{figure}

Az ablak közepén találhatóak a különbözõ ritmus-összehasonlítási, illetve a klaszterezési módszerek közötti választást lehetõvé panelek. Ezek pontosan egy összehasonlító módszer és pontosan egy klaszterezõ algoritmus kiválasztását engedik meg.

A kiválasztott klaszterezés paraméterei a jobb oldali paraméterszerkesztõ panelen állíthatóak. A panelen minden lehetséges paraméter szerepel, de csak azt lehet állítani, amely a kiválasztott klaszterezés számára szükséges. A hierarchikus (single, complete, average linkage) módszerek esetében ez csak az osztályok számát ($K$) jelenti, a $k$-means különbözõ típusaihoz ehhez még a \textit{Loop count}-ot is be kell állítanunk (hány próbálkozásból válassza ki a minimális négyzetes hibaösszegût), míg a DBSCAN kiválasztása csak a $minPts$ és az $\varepsilon$ megadását igényli.

A futást a \textit{Classify!} feliratú gomb megnyomásával indíthatjuk, az eredmények megjelenítése pedig az alsó, csak olvasható kimeneti panelen történik. A kapott klaszterek külön sorba kerülnek, az elemeiket pedig a katalógusfájlból származó azonosítók jelölik.

Az ablak jobb oldalának alsó részén helyezkedik el az eredményül kapott klaszterezésre számított metrikákat tartalmazó panel. Itt nyomon követhetjük a négyzetes távolságösszeg, maximális átmérõ, stb\dots változását a különbözõ paraméterekre.

%----------------------------------------------------------------------------
\section{Távolságmátrixok szerializálása és betöltése}
%----------------------------------------------------------------------------

Abban az esetben, ha nem kívánjuk gyakran változtatni a vizsgált adathalmazt, érdemes lehet az elemek közötti távolságokat csak egyszer meghatározni, majd fájlba írni. Ezzel megspóroljuk, hogy az esetleges késõbbi, különbözõ paraméterû klaszterezések újra és újra elõállítsák ugyanazt a távolságmátrixot.

Ehhez a funkcióhoz mind a távolságmátrix szerializálását, mind a fájlból való visszatöltését implementálni kellett.

%----------------------------------------------------------------------------
\section{Nexus fájlok generálása}\label{sect:nexus}
%----------------------------------------------------------------------------

Az elkészült szoftver rendelkezik azzal a funkcióval, hogy speciális, úgynevezett Nexus fájlokat generáljon, amelyek a következõ fejezetben ismertetett SplitsTree nevû alkalmazásnak adhatóak át bemeneti fájlként. Ezekben a NEX kiterjesztésû fájlokban is megtalálható a távolságmátrix, illetve megadott szabályok szerint elõállított metaadatok. 

Egy ilyen fájlra láthatunk példát az \ref{app:nexus}. számú függelékben.

%----------------------------------------------------------------------------
\section{Felhasznált technológiák}
%----------------------------------------------------------------------------

A programozási folyamat során gyakran találkoztam olyan problémával, melyre annak általánossága miatt már jól ismert és publikusan hozzáférhetõ megoldások érhetõek el. Az alábbi lista tartalmazza a megvalósítás és a dokumentálás során felhasznált technológiákat.

\begin{itemize}
\item  A katalógusfájl beolvasása során szükségem volt egy kétirányú \texttt{Map} implementációra, melyre az Apache Commons Collections könyvtárának \texttt{BidiMap} osztálya nyújtott megoldást.

\item A debug során sok segítséget nyújtott a prioritási szintenkénti naplózást lehetõvé tevõ Log4j csomag.

\item A katalógusfájl soronkénti feldolgozását és a fájlba író mûveleteket a Google Guava könyvtárának fájlmûveleteket egyszerûsítõ eljárásaink segítségével oldottam meg. 

\item A grafikus felület létrehozásához az Eclipse SWT grafikus könyvtárát használtam.

\item Az Apache Commons IO könyvtára a rekurzív fájlbeolvasásban segített.

\item Az UML diagramok a Gliffy nevû online diagramszerkesztõ alkalmazás segítségével készültek.

\item Az ábrákat a Pixlr nevû online képszerkesztõvel színeztem ki.

\item A munka során végig verziókezelõ rendszer segítségével naplóztam az elvégzett feladatokat és tartottam biztonságos helyen a forráskódot. Ehhez a \url{http://code.google.com} által rendelkezésre bocsátott alkalmazásokat és tárhelyet használtam.

\item Az Eclipse Metrics pluginja segítségével követtem a projektet alkotó osztályok számának, méretének és komplexitásának növekedését.

\item A kották MuseScore nevû kottaszerkesztõ program segítségével készültek.

\item A dolgozat \LaTeX-ben készült.
\end{itemize}